<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stable Diffusion 画像 → プロンプト抽出（ドラッグ＆ドロップ対応）</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #151a2c;
      --ink: #e7ecff;
      --muted: #9aa4c7;
      --accent: #7aa2ff;
      --danger: #ff7a9e;
      --ok: #6ee7b7;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --round: 16px;
    }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 24px; background: radial-gradient(1200px 600px at 10% -10%, #1a2250 0%, var(--bg) 40%);
      color: var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    h1 { font-size: 20px; margin: 0 0 12px; letter-spacing: .2px; }
    p.lead { margin: 0 0 18px; color: var(--muted); }
    .wrap { max-width: 1100px; margin: 0 auto; }
    .dropzone {
      border: 2px dashed #3a4580; border-radius: var(--round); padding: 28px; background: rgba(20,25,50,.5);
      display: flex; gap: 18px; align-items: center; justify-content: space-between; flex-wrap: wrap;
      transition: background .15s ease, border-color .15s ease, transform .06s ease;
    }
    .dropzone.dragover { background: rgba(60, 90, 200, .18); border-color: var(--accent); transform: scale(1.005); }
    .dz-left { display: flex; gap: 14px; align-items: center; }
    .dz-ico { width: 44px; height: 44px; border-radius: 12px; background: linear-gradient(135deg, #2b3566, #1d244a); display: grid; place-items: center; }
    .dz-ico svg { width: 26px; height: 26px; opacity: .9; }
    .dz-text { line-height: 1.4; }
    .dz-text strong { color: var(--ink); }
    .dz-text span { color: var(--muted); font-size: 14px; }
    .dz-btns { display: flex; gap: 10px; }
    button, .btn { cursor: pointer; border: 1px solid #3a4580; background: #121733; color: var(--ink); padding: 10px 14px; border-radius: 12px; font-weight: 600; }
    button:hover, .btn:hover { border-color: var(--accent); }
    input[type="file"] { display: none; }

    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 14px; margin-top: 18px; }
    .card { background: var(--panel); border: 1px solid #232a48; border-radius: var(--round); overflow: clip; display: flex; flex-direction: column; }
    .thumb { position: relative; aspect-ratio: 1/1; background: #0e1226; display: grid; place-items: center; }
    .thumb img { max-width: 100%; max-height: 100%; object-fit: contain; display: block; }
    .meta { padding: 14px; display: grid; gap: 12px; }
    .filetitle { font-weight: 700; font-size: 14px; color: var(--ink); word-break: break-all; }
    .kv { display: grid; gap: 6px; font-size: 13px; }
    .kv dt { color: var(--muted); }
    .kv dd { margin: 0; white-space: pre-wrap; background: #0f1430; border: 1px solid #2a335a; padding: 8px; border-radius: 10px; font-family: var(--mono); max-height: 180px; overflow: auto; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .pill { font-size: 12px; padding: 6px 8px; border-radius: 999px; border: 1px solid #2a335a; background: #0f1430; color: var(--muted); }
    .actions { display: flex; gap: 8px; }
    .ok { color: var(--ok); }
    .warn { color: var(--danger); }
    .mono { font-family: var(--mono); }
    .small { font-size: 12px; color: var(--muted); }
    .footer { margin-top: 18px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Stable Diffusion 画像 → プロンプト抽出</h1>
    <p class="lead">PNG / JPG / WebP をドロップ or 選択すると、埋め込まれた <span class="mono">parameters</span> / <span class="mono">sd-metadata</span> / <span class="mono">prompt</span> などから <strong>プロンプト</strong>と<strong>ネガティブプロンプト</strong>、手元の設定（Steps / Sampler / CFG / Seed / Size / Model など）を解析します。</p>

    <div id="dropzone" class="dropzone" tabindex="0">
      <div class="dz-left">
        <div class="dz-ico" aria-hidden="true">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 16a1 1 0 0 1-1-1V7.41L8.7 9.7a1 1 0 1 1-1.4-1.42l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.42L13 7.4V15a1 1 0 0 1-1 1Z"/><path d="M5 15a1 1 0 1 1 2 0v3h10v-3a1 1 0 1 1 2 0v3a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-3Z"/></svg>
        </div>
        <div class="dz-text">
          <div><strong>ここに画像をドラッグ＆ドロップ</strong></div>
          <span>または ボタンから選択</span>
        </div>
      </div>
      <div class="dz-btns">
        <label class="btn">画像を選択<input id="file" type="file" accept="image/png,image/jpeg,image/webp" multiple></label>
        <button id="clear">結果をクリア</button>
      </div>
    </div>

    <div id="grid" class="grid" aria-live="polite"></div>
    <div class="footer">⚠️ 画像のメタデータが削除されている場合は抽出できません（SNSや一部エディタで消されることがあります）。PNG の <span class="mono">tEXt/iTXt/zTXt</span>、JPEG の EXIF / XMP / COM、WebP のメタ情報、さらにバイナリ中のテキスト走査も試みます。すべて処理はブラウザ内で完結し、画像は外部送信されません。</div>
  </div>

  <script>
    // ===== Utilities =====
    const $ = (sel, el=document) => el.querySelector(sel);
    const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

    function escapeHTML(s){ return s.replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m])); }

    function buf2str(ab, enc='utf-8'){ try { return new TextDecoder(enc, {fatal:false}).decode(ab); } catch { return ''; } }

    function decodeUTF16BE(u8){ let out = ''; for (let i=0;i+1<u8.length;i+=2){ out += String.fromCharCode((u8[i]<<8)|u8[i+1]); } return out; }

    function decodeWithBomOrFallback(u8){
      // BOM 判定
      if (u8.length >= 3 && u8[0]===0xEF && u8[1]===0xBB && u8[2]===0xBF){ return buf2str(u8.slice(3)); }
      if (u8.length >= 2 && u8[0]===0xFE && u8[1]===0xFF){ try { return buf2str(u8.slice(2), 'utf-16be'); } catch { return decodeUTF16BE(u8.slice(2)); } }
      if (u8.length >= 2 && u8[0]===0xFF && u8[1]===0xFE){ return buf2str(u8.slice(2), 'utf-16le'); }
      // 候補をスコアリング
      const candidates = [buf2str(u8), buf2str(u8, 'utf-16le'), (()=>{try{return buf2str(u8,'utf-16be');}catch{return decodeUTF16BE(u8);} })(), buf2str(u8, 'iso-8859-1')];
      let best = candidates[0], bestScore = -1;
      const keys = [/Negative prompt:/i, /Steps\s*:/, /Sampler\s*:/i, /CFG\s*scale/i, /Seed\s*:/, /Size\s*:/, /<x:xmpmeta/i, /sd-metadata/i, /"prompt"\s*:/i];
      for (const text of candidates){
        let score = 0; for (const k of keys){ if (k.test(text)) score += 2; }
        const asciiRatio = (text.match(/[\x20-\x7E]/g)||[]).length / Math.max(1,text.length);
        score += asciiRatio; if (score > bestScore){ bestScore = score; best = text; }
      }
      return best;
    }

    async function zlibInflate(u8){
      if ('DecompressionStream' in window){
        try { const ds = new DecompressionStream('deflate'); const ab = await new Response(new Blob([u8]).stream().pipeThrough(ds)).arrayBuffer(); return buf2str(ab); }
        catch (e){ /* ignore */ }
      }
      throw new Error('zlib inflate not supported in this browser');
    }

    // ===== PNG Parsing =====
    function isPNG(u8){ const sig = [137,80,78,71,13,10,26,10]; return sig.every((b,i)=>u8[i]===b); }

    async function parsePNG(ab){
      const u8 = new Uint8Array(ab); if (!isPNG(u8)) return null;
      const dv = new DataView(ab); let off = 8; const textMap = new Map();
      while (off + 8 <= u8.length){
        const len = dv.getUint32(off); off += 4; const typeArr = u8.slice(off, off+4); off += 4; const type = buf2str(typeArr); const data = u8.slice(off, off+len); off += len; off += 4; // crc
        try {
          if (type === 'tEXt'){
            const nul = data.indexOf(0); const key = buf2str(data.slice(0, Math.max(0,nul)) || new Uint8Array()); const val = buf2str(data.slice(Math.max(0,nul+1))); if (key) textMap.set(key, (textMap.get(key)||'') + val);
          } else if (type === 'iTXt'){
            let p = 0; const readNullTerm = ()=>{ const i = data.indexOf(0,p); const out = buf2str(data.slice(p, i<0?data.length:i)); p = (i<0?data.length:i)+1; return out; };
            const key = readNullTerm(); const compFlag = data[p++]; p++; /* compMethod */ readNullTerm(); /* lang */ readNullTerm(); /* translated */
            const rest = data.slice(p); let val = ''; if (compFlag === 1){ try { val = await zlibInflate(rest); } catch{} } else { val = buf2str(rest); } if (key) textMap.set(key, (textMap.get(key)||'') + val);
          } else if (type === 'zTXt'){
            const nul = data.indexOf(0); const key = buf2str(data.slice(0, Math.max(0,nul)) || new Uint8Array()); const compData = data.slice(nul+2); try { const val = await zlibInflate(compData); if (key) textMap.set(key, (textMap.get(key)||'') + val); } catch{}
          }
        } catch(e){ /* ignore */ }
        if (type === 'IEND') break;
      }
      return { textMap };
    }

    // ===== WebP (RIFF) Parsing =====
    function isRIFFWEBP(u8){ if (u8.length < 12) return false; return buf2str(u8.slice(0,4))==='RIFF' && buf2str(u8.slice(8,12))==='WEBP'; }

    function parseEXIFfromTIFF(exifU8){
      if (!exifU8 || exifU8.length < 6) return {};
      let start = 0; const sig = buf2str(exifU8.slice(0,6)); if (sig.startsWith('Exif')) start = 6;
      const dv = new DataView(exifU8.buffer, exifU8.byteOffset + start, exifU8.byteLength - start);
      if (dv.byteLength < 8) return {};
      const little = (dv.getUint16(0, false) === 0x4949); // 'II'
      if (dv.getUint16(2, little) !== 42) return {};
      const ifd0Off = dv.getUint32(4, little);
      const out = {}; const seen = new Set();
      function readIFD(offset){
        if (offset <= 0 || offset + 2 > dv.byteLength) return;
        const num = dv.getUint16(offset, little); let p = offset + 2;
        for (let i=0;i<num;i++){
          if (p + 12 > dv.byteLength) break;
          const tag = dv.getUint16(p, little); const type = dv.getUint16(p+2, little); const count = dv.getUint32(p+4, little); const valOff = dv.getUint32(p+8, little);
          const typeSize = {1:1,2:1,3:2,4:4,5:8,7:1,9:4,10:8}[type] || 1; const bytes = count * typeSize; const vOff = bytes <= 4 ? (p+8) : valOff;
          let value; if (vOff + bytes <= dv.byteLength){ const slice = new Uint8Array(dv.buffer, dv.byteOffset + vOff, Math.min(bytes, dv.byteLength - vOff));
            if (type === 2){ value = buf2str(slice).replace(/\x00+$/,''); }
            else if (tag === 0x9286){ // UserComment
              if (slice.length >= 8){
                const code = buf2str(slice.slice(0,8)).replace(/\x00+$/,'');
                const body = slice.slice(8);
                if (code.startsWith('UNICODE')){
                  let s=''; if (little){ for (let j=0;j+1<body.length;j+=2){ s += String.fromCharCode(body[j] | (body[j+1]<<8)); } } else { for (let j=0;j+1<body.length;j+=2){ s += String.fromCharCode((body[j]<<8) | body[j+1]); } }
                  value = s.replace(/\x00+$/,'');
                } else { value = buf2str(body).replace(/\x00+$/,''); }
              }
            }
            else if (type === 1 || type === 7){ value = buf2str(slice).replace(/\x00+$/,''); }
          }
          if (typeof value === 'string' && value){ if (tag === 0x010E) out.ImageDescription = value; if (tag === 0x9286) out.UserComment = value; }
          if (tag === 0x8769 && !seen.has(valOff)){ seen.add(valOff); readIFD(valOff); }
          p += 12;
        }
      }
      readIFD(ifd0Off); return out;
    }

    async function parseWEBP(ab){
      const u8 = new Uint8Array(ab); if (!isRIFFWEBP(u8)) return null;
      const dv = new DataView(ab); let off = 12; let exifU8 = null, xmpU8 = null;
      while (off + 8 <= dv.byteLength){
        const fourCC = buf2str(u8.slice(off, off+4)); off += 4; const size = dv.getUint32(off, true); off += 4;
        const chunkStart = off; const chunkEnd = Math.min(chunkStart + size + (size & 1), dv.byteLength);
        const payload = new Uint8Array(dv.buffer, chunkStart, Math.max(0, Math.min(size, dv.byteLength - chunkStart)));
        if (fourCC === 'EXIF') exifU8 = payload; if (fourCC === 'XMP ') xmpU8 = payload; off = chunkEnd;
      }
      if (xmpU8){ const xmpText = decodeWithBomOrFallback(xmpU8); if (xmpText){ const asJson = parseSDJson(xmpText); if (asJson) return { source:'WEBP XMP', text:xmpText.slice(0,2000), result:asJson }; const fromTxt = parseA1111ParametersText(xmpText); if (fromTxt) return { source:'WEBP XMP (A1111テキスト)', text:xmpText.slice(0,2000), result:fromTxt }; } }
      if (exifU8){ const ex = parseEXIFfromTIFF(exifU8); const joined = [ex.UserComment, ex.ImageDescription].filter(Boolean).join('\n'); if (joined){ const asJson = parseSDJson(joined); if (asJson) return { source:'WEBP EXIF(UserComment/Desc) JSON', text:joined.slice(0,2000), result:asJson }; const asTxt = parseA1111ParametersText(joined); if (asTxt) return { source:'WEBP EXIF(UserComment/Desc)', text:joined.slice(0,2000), result:asTxt }; } }
      return { source:'WEBP', text:'', result:null };
    }

    // ===== JPEG Parsing =====
    function isJPEG(u8){ return u8.length >= 2 && u8[0]===0xFF && u8[1]===0xD8; }

    function parseJPEG(ab){
      const u8 = new Uint8Array(ab); if (!isJPEG(u8)) return null;
      let off = 2; let exifU8=null, xmpU8=null; const comTexts=[];
      const len = u8.length;
      while (off + 4 <= len){
        if (u8[off] !== 0xFF){ // search next marker sync (be tolerant)
          const next = u8.indexOf(0xFF, off); if (next < 0) break; off = next;
        }
        let marker = u8[off+1]; off += 2;
        if (marker === 0xD9 /*EOI*/){ break; }
        if (marker === 0xDA /*SOS*/){ break; }
        if (off + 2 > len) break;
        const segLen = (u8[off]<<8) | u8[off+1]; off += 2;
        if (segLen < 2 || off + segLen - 2 > len) break;
        const payload = u8.slice(off, off + segLen - 2);
        if (marker === 0xE1){ // APP1: EXIF or XMP
          const head6 = buf2str(payload.slice(0,6));
          if (head6.startsWith('Exif')){ exifU8 = payload; }
          else {
            const label = buf2str(payload.slice(0, 29)); // 'http://ns.adobe.com/xap/1.0/' + \0
            if (label.startsWith('http://ns.adobe.com/xap/1.0/')){
              const zero = payload.indexOf(0, 0);
              const xml = payload.slice((zero>=0?zero+1:29));
              xmpU8 = xml;
            }
          }
        } else if (marker === 0xFE){ // COM comment
          const txt = decodeWithBomOrFallback(payload);
          if (txt) comTexts.push(txt);
        }
        off += segLen - 2;
      }

      if (xmpU8){ const xmpText = decodeWithBomOrFallback(xmpU8); if (xmpText){ const asJson = parseSDJson(xmpText); if (asJson) return { source:'JPEG XMP', text:xmpText.slice(0,2000), result:asJson }; const fromTxt = parseA1111ParametersText(xmpText); if (fromTxt) return { source:'JPEG XMP (A1111テキスト)', text:xmpText.slice(0,2000), result:fromTxt }; } }
      if (exifU8){ const ex = parseEXIFfromTIFF(exifU8); const joined = [ex.UserComment, ex.ImageDescription].filter(Boolean).join('\n'); if (joined){ const asJson = parseSDJson(joined); if (asJson) return { source:'JPEG EXIF(UserComment/Desc) JSON', text:joined.slice(0,2000), result:asJson }; const asTxt = parseA1111ParametersText(joined); if (asTxt) return { source:'JPEG EXIF(UserComment/Desc)', text:joined.slice(0,2000), result:asTxt }; } }
      for (const com of comTexts){ const asJson = parseSDJson(com); if (asJson) return { source:'JPEG COM(JSON)', text:com.slice(0,2000), result:asJson }; const asTxt = parseA1111ParametersText(com); if (asTxt) return { source:'JPEG COM', text:com.slice(0,2000), result:asTxt }; }
      return { source:'JPEG', text:(comTexts[0]||'' ).slice(0,2000), result:null };
    }

    // ===== JPEG & Generic Quick Scan =====
    function quickScanText(ab){
      const u8 = new Uint8Array(ab);
      const utf8 = buf2str(u8);
      const u16 = buf2str(u8, 'utf-16le');
      const u16be = (()=>{try{return buf2str(u8,'utf-16be');}catch{return decodeUTF16BE(u8);} })();
      const latin = buf2str(u8, 'iso-8859-1');
      const variants = [utf8, u16, u16be, latin].filter(Boolean);
      const out = { };
      for (const str of variants){
        const jsonMatches = str.match(/[\{\[][^^\x00]*?(sd-metadata|"prompt"|"negative_prompt"|"Workflow"|"Comfy"): [^\x00]*?[\}\]]/g);
        if (jsonMatches){ out.jsonBlobs = (out.jsonBlobs||[]).concat(jsonMatches).slice(0,3); }
        const negIdx = str.indexOf('Negative prompt:');
        const paramIdx = str.indexOf('Steps:');
        const paramsEndIdx = str.indexOf('\x00', paramIdx+1);
        if (negIdx >= 0){ const negTail = str.slice(negIdx).split(/\r?\n/).slice(0,4).join('\n'); out.negBlock = out.negBlock || negTail; }
        if (paramIdx >= 0){ const tail = str.slice(paramIdx, paramsEndIdx>0?paramsEndIdx:paramIdx+2000); out.paramLine = out.paramLine || tail.split(/\r?\n/)[0]; }
        const bigParam = str.match(/parameters\x00?([^\x00]{1,20000})/i); if (bigParam && bigParam[1]){ out.parameters = out.parameters || bigParam[1]; }
        if (!out._raw && (out.negBlock || out.paramLine || out.parameters || (out.jsonBlobs && out.jsonBlobs.length))){ out._raw = [out.parameters, out.negBlock, out.paramLine, (out.jsonBlobs||[])[0]].filter(Boolean).join('\n'); }
      }
      return out;
    }

    // ===== A1111 "parameters" text → structured =====
    function parseA1111ParametersText(raw){
      if (!raw) return null;
      // 正規化（NUL, 改行, 全角コロン）
      let text = String(raw)
        .replace(/\x00+/g, '')
        .replace(/\r\n?/g, '\n')
        .replace(/\uFF1A/g, ':');

      // マーカー位置を探索
      const lower = text.toLowerCase();
      const negKey = 'negative prompt:';
      const stepsKey = 'steps:';
      const negIdx = lower.indexOf(negKey);
      const stepsIdx = lower.indexOf(stepsKey);

      let positive = '';
      let negative = '';

      if (negIdx >= 0){
        positive = text.slice(0, negIdx).trim();
        const negStart = negIdx + negKey.length;
        const nextLine = text.indexOf('\n', negStart);
        const negEnd = (stepsIdx >= 0 && stepsIdx > negStart) ? stepsIdx : (nextLine >= 0 ? nextLine : text.length);
        negative = text.slice(negStart, negEnd).trim();
      } else if (stepsIdx >= 0){
        positive = text.slice(0, stepsIdx).trim();
      } else {
        positive = text.split('\n')[0].trim();
      }

      // 設定行の抽出（Steps: を含む行のみ）
      let settingsLine = '';
      if (stepsIdx >= 0){
        const lineEnd = text.indexOf('\n', stepsIdx);
        settingsLine = text.slice(stepsIdx, lineEnd >= 0 ? lineEnd : text.length);
      }

      const settings = {};
      settingsLine.split(',').forEach(seg => {
        const i = seg.indexOf(':');
        if (i > -1){ const key = seg.slice(0, i).trim(); const val = seg.slice(i+1).trim(); if (key) settings[key] = val; }
      });

      const size = settings['Size'] || settings['Hires size'] || '';
      const seed = settings['Seed'] || settings['Batch seed'] || '';
      const sampler = settings['Sampler'] || settings['Sampler Name'] || '';
      const cfg = settings['CFG scale'] || settings['CFG Scale'] || '';
      const steps = settings['Steps'] || '';
      const model = settings['Model'] || settings['Model hash'] || settings['Model hash(es)'] || '';

      return { positive, negative, settings, summary: { steps, sampler, cfg, seed, size, model } };
    }

    // ===== sd-metadata JSON → structured =====
    function parseSDJson(jsonText){
      try {
        const j = JSON.parse(jsonText);
        const positive = j.prompt || j.Prompt || j.positive || j['Positive prompt'] || '';
        const negative = j.negative_prompt || j.NegativePrompt || j['Negative prompt'] || '';
        const steps = j.steps || (j.settings && j.settings.steps) || '';
        const sampler = j.sampler || j.sampler_name || (j.settings && j.settings.sampler) || '';
        const cfg = j.cfg_scale || j.cfg || (j.settings && j.settings.cfg_scale) || '';
        const seed = j.seed || j.Seed || (j.settings && j.settings.seed) || '';
        const size = (j.width && j.height) ? `${j.width}x${j.height}` : '';
        const model = j.model || j.model_name || j.model_hash || '';
        return { positive, negative, summary:{ steps, sampler, cfg, seed, size, model }, settings: j };
      } catch { return null; }
    }

    // ===== Main: handle files =====
    const dropzone = $('#dropzone');
    const fileInput = $('#file');
    const grid = $('#grid');

    function cardSkeleton(name){
      const el = document.createElement('div');
      el.className = 'card';
      el.innerHTML = `
        <div class="thumb"><span class="small">プレビュー準備中…</span></div>
        <div class="meta">
          <div class="filetitle">${escapeHTML(name)}</div>
          <div class="row actions">
            <button class="copy-pos" title="プロンプトをコピー">Promptコピー</button>
            <button class="copy-neg" title="ネガティブプロンプトをコピー">Negativeコピー</button>
          </div>
          <dl class="kv">
            <dt>Prompt</dt>
            <dd class="pos">—</dd>
            <dt>Negative Prompt</dt>
            <dd class="neg">—</dd>
            <dt>設定 / サマリー</dt>
            <dd class="sum">—</dd>
            <dt>生メタデータ（抜粋）</dt>
            <dd class="raw">—</dd>
          </dl>
          <div class="row">
            <span class="pill info">情報ソース: <span class="src">—</span></span>
            <span class="pill status">状態: <span class="st">解析中</span></span>
          </div>
        </div>`;
      return el;
    }

    function setThumb(el, file){
      const img = document.createElement('img'); const url = URL.createObjectURL(file); img.onload = ()=> URL.revokeObjectURL(url); img.src = url;
      const box = el.querySelector('.thumb'); box.innerHTML = ''; box.appendChild(img);
    }

    function kvToString(obj){ const parts = []; for (const [k,v] of Object.entries(obj||{})){ if (v === undefined || v === null || v === '') continue; parts.push(`${k}: ${v}`); } return parts.join(', '); }

    function attachCopyHandlers(card, data){
      const posBtn = card.querySelector('.copy-pos');
      const negBtn = card.querySelector('.copy-neg');
      const status = card.querySelector('.status .st');
      function blip(btn){ const old = btn.textContent; btn.textContent = '✓ コピーしました'; setTimeout(()=>btn.textContent = old, 900); }
      posBtn.onclick = ()=>{ navigator.clipboard.writeText(data.positive || '').then(()=>blip(posBtn)); };
      negBtn.onclick = ()=>{ navigator.clipboard.writeText(data.negative || '').then(()=>blip(negBtn)); };
      status.textContent = '完了'; status.classList.add('ok');
    }

    async function handleFile(file){
      const card = cardSkeleton(file.name); grid.prepend(card); setThumb(card, file);
      const st = card.querySelector('.status .st'); const src = card.querySelector('.src'); const posEl = card.querySelector('.pos'); const negEl = card.querySelector('.neg'); const sumEl = card.querySelector('.sum'); const rawEl = card.querySelector('.raw');

      const ab = await file.arrayBuffer(); let result = null; let source = '—'; let rawSnippet = '';

      // 0) Try WEBP
      try { const w = await parseWEBP(ab); if (w && w.result){ result = w.result; source = w.source; rawSnippet = w.text; } } catch(e){ /* ignore */ }

      // 1) Try PNG
      if (!result){
        try {
          const png = await parsePNG(ab);
          if (png){
            const prefKeys = ['parameters','sd-metadata','prompt','Description','Comment'];
            for (const k of prefKeys){ if (png.textMap.has(k)){ const val = png.textMap.get(k); const asJson = parseSDJson(val); if (asJson){ result = asJson; source = `PNG iTXt/tEXt: ${k} (JSON)`; rawSnippet = val.slice(0, 2000); break; } const asTxt = parseA1111ParametersText(val); if (asTxt){ result = asTxt; source = `PNG iTXt/tEXt: ${k}`; rawSnippet = val.slice(0, 2000); break; } } }
            if (!result && png.textMap.size){ const joined = Array.from(png.textMap.values()).join('\n'); const asJson = parseSDJson(joined) || (joined.includes('{')?parseSDJson(joined.slice(joined.indexOf('{'))):null); result = asJson || parseA1111ParametersText(joined); if (result){ source = 'PNG iTXt/tEXt (総合)'; rawSnippet = joined.slice(0, 2000); } }
          }
        } catch(e){ /* ignore */ }
      }

      // 2) Try JPEG (EXIF / XMP / COM)
      if (!result){
        try {
          const jpg = parseJPEG(ab);
          if (jpg && jpg.result){ result = jpg.result; source = jpg.source; rawSnippet = jpg.text; }
        } catch(e){ /* ignore */ }
      }

      // 3) Generic quick scan fallback
      if (!result){
        const hits = quickScanText(ab);
        if (hits.jsonBlobs){ for (const blob of hits.jsonBlobs){ const asj = parseSDJson(blob); if (asj){ result = asj; source = 'バイナリ中のJSON (sd-metadata 等)'; rawSnippet = blob.slice(0,2000); break; } } }
        if (!result && hits.parameters){ const a = parseA1111ParametersText(hits.parameters); if (a){ result = a; source = 'バイナリ中の parameters テキスト'; rawSnippet = hits.parameters.slice(0, 2000); } }
        if (!result && (hits.negBlock || hits.paramLine)){ const blob = [hits.negBlock||'', hits.paramLine||''].join('\n'); const a = parseA1111ParametersText(blob); if (a){ result = a; source = 'バイナリ中のヒューリスティック抽出'; rawSnippet = blob.slice(0, 2000); } }
        if (!rawSnippet && hits._raw) rawSnippet = hits._raw.slice(0, 2000);
      }

      if (result){
        posEl.textContent = result.positive || '—';
        negEl.textContent = result.negative || '—';
        const kv = kvToString(result.summary || {}); sumEl.textContent = kv || '—';
        rawEl.textContent = rawSnippet || '—'; src.textContent = source; attachCopyHandlers(card, result);
      } else {
        st.textContent = '見つかりませんでした（メタデータなし/削除の可能性 or 未対応形式）'; st.classList.add('warn');
        posEl.textContent = '—'; negEl.textContent = '—'; sumEl.textContent = '—'; rawEl.textContent = '—'; src.textContent = '—';
      }
    }

    // ===== Wire up UI =====
    fileInput.addEventListener('change', (e)=>{ for (const f of e.target.files) handleFile(f); fileInput.value = ''; });
    ['dragenter','dragover'].forEach(ev=>dropzone.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); dropzone.classList.add('dragover'); }));
    ;['dragleave','dragend','drop'].forEach(ev=>dropzone.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('dragover'); }));
    dropzone.addEventListener('drop', e=>{ const files = e.dataTransfer.files; for (const f of files){ handleFile(f); } });
    $('#clear').addEventListener('click', ()=>{ grid.innerHTML=''; });

    dropzone.addEventListener('keydown', (e)=>{ if (e.key==='Enter' || e.key===' '){ $('#file').click(); }});
  </script>
</body>
</html>
